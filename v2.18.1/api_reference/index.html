<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · RootedTrees.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://SciML.github.io/RootedTrees.jl/stable/api_reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RootedTrees.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/basics/">Basics, printing, and visualization</a></li><li><a class="tocitem" href="../tutorials/RK_order_conditions/">Runge-Kutta methods</a></li><li><a class="tocitem" href="../tutorials/ARK_order_conditions/">Additive Runge-Kutta methods</a></li><li><a class="tocitem" href="../tutorials/Rosenbrock_order_conditions/">Rosenbrock methods</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/RootedTrees.jl/blob/main/docs/src/api_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RootedTrees.jl-API"><a class="docs-heading-anchor" href="#RootedTrees.jl-API">RootedTrees.jl API</a><a id="RootedTrees.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#RootedTrees.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTrees" href="#RootedTrees.RootedTrees"><code>RootedTrees.RootedTrees</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>RootedTrees</strong></p><p><a href="https://SciML.github.io/RootedTrees.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Docs-stable"/></a> <a href="https://SciML.github.io/RootedTrees.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Docs-dev"/></a> <a href="https://github.com/SciML/RootedTrees.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/RootedTrees.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://coveralls.io/github/SciML/RootedTrees.jl?branch=main"><img src="https://coveralls.io/repos/github/SciML/RootedTrees.jl/badge.svg?branch=main" alt="Coverage Status"/></a> <a href="https://codecov.io/gh/SciML/RootedTrees.jl"><img src="https://codecov.io/gh/SciML/RootedTrees.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-success.svg" alt="License: MIT"/></a> <a href="https://doi.org/10.5281/zenodo.5534590"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.5534590.svg" alt="DOI"/></a> <a href="https://pkgs.genieframework.com?packages=RootedTrees"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/RootedTrees" alt="Downloads"/></a></p><p>A collection of functionality around rooted trees to generate order conditions for Runge-Kutta methods in <a href="https://julialang.org/">Julia</a>. This package also provides basic functionality for <a href="https://github.com/ranocha/BSeries.jl">BSeries.jl</a>.</p><p><strong>API Documentation</strong></p><p>The API of RootedTrees.jl is documented in the following. Additional information on each function is available in their docstrings and in the <a href="https://SciML.github.io/RootedTrees.jl/stable">online documentation</a>.</p><p><strong>Construction</strong></p><p><code>RootedTree</code>s are represented using level sequences, i.e., <code>AbstractVector</code>s containing the distances of the nodes from the root, see</p><ul><li>Beyer, Terry, and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul><p><code>RootedTree</code>s can be constructed from their level sequence using</p><pre><code class="language-julia hljs">julia&gt; t = rootedtree([1, 2, 3, 2])
RootedTree{Int64}: [1, 2, 3, 2]</code></pre><p>In the notation of <a href="https://doi.org/10.1002/9781119121534">Butcher (Numerical Methods for ODEs, 2016)</a>, this tree can be written as <code>[[τ] τ]</code> or <code>(τ ∘ τ) ∘ (τ ∘ τ)</code>, where <code>∘</code> is the non-associative Butcher product of <code>RootedTree</code>s, which is also implemented.</p><p>To get the representation of a <code>RootedTree</code> introduced by Butcher, use <code>butcher_representation</code>:</p><pre><code class="language-julia hljs">julia&gt; t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])
RootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]

julia&gt; butcher_representation(t)
&quot;[[[τ]τ²]τ⁵]&quot;</code></pre><p>There are also some simple plot recipes for <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. Thus, you can visualize a rooted tree <code>t</code> using <code>plot(t)</code> when <code>using Plots</code>.</p><p>Additionally, there is an un-exported function <code>RootedTrees.latexify</code> that can generate LaTeX code for a rooted tree <code>t</code> based on the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a>. The relevant code that needs to be included in the preamble can be obtained from the docstring of <code>RootedTrees.latexify</code> (type <code>?</code> and <code>RootedTrees.latexify</code> in the Julia REPL). The same format is used when you are <code>using Latexify</code> and their function <code>latexify</code>, see <a href="https://github.com/korsbo/Latexify.jl">Latexify.jl</a>.</p><p><strong>Iteration over <code>RootedTree</code>s</strong></p><p>A <code>RootedTreeIterator(order::Integer)</code> can be used to iterate efficiently over all <code>RootedTree</code>s of a given <code>order</code>.</p><p>Be careful that the iterator is stateful for efficiency reasons, so you might need to use <code>copy</code> appropriately, e.g.,</p><pre><code class="language-julia hljs">julia&gt; map(identity, RootedTreeIterator(4))
4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]

julia&gt; map(copy, RootedTreeIterator(4))
4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:
 RootedTree{Int64}: [1, 2, 3, 4]
 RootedTree{Int64}: [1, 2, 3, 3]
 RootedTree{Int64}: [1, 2, 3, 2]
 RootedTree{Int64}: [1, 2, 2, 2]</code></pre><p><strong>Functions on Trees</strong></p><p>The usual functions on <code>RootedTree</code>s are implemented, cf. <a href="https://doi.org/10.1002/9781119121534">Butcher (Numerical Methods for ODEs, 2016)</a>.</p><ul><li><code>order(t::RootedTree)</code>: The order of a <code>RootedTree</code>, i.e., the length of its level sequence.</li><li><code>σ(t::RootedTree)</code> or <code>symmetry(t)</code>: The symmetry <code>σ</code> of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of <code>t</code>.</li><li><code>γ(t::RootedTree)</code> or <code>density(t)</code>: The density <code>γ(t)</code> of a rooted tree, i.e., the product over all vertices of <code>t</code> of the order of the subtree rooted at that vertex.</li><li><code>α(t::RootedTree)</code>: The number of monotonic labelings of <code>t</code> not equivalent under the symmetry group.</li><li><code>β(t::RootedTree)</code>: The total number of labelings of <code>t</code> not equivalent under the symmetry group.</li></ul><p>Additionally, functions on trees connected to Runge-Kutta methods are implemented.</p><ul><li><code>elementary_weight(t, A, b, c)</code>: Compute the elementary weight Φ(<code>t</code>) of <code>t::RootedTree</code> for the Butcher coefficients <code>A, b, c</code> of a Runge-Kutta method.</li><li><code>derivative_weight(t, A, b, c)</code>: Compute the derivative weight (ΦᵢD)(<code>t</code>) of <code>t</code> for the Butcher coefficients <code>A, b, c</code> of a Runge-Kutta method.</li><li><code>residual_order_condition(t, A, b, c)</code>: The residual of the order condition <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with elementary weight <code>Φ(t)</code>, density <code>γ(t)</code>, and symmetry <code>σ(t)</code> of the rooted tree <code>t</code> for the Runge-Kutta method with Butcher coefficients <code>A, b, c</code>.</li></ul><p><strong>Brief Changelog</strong></p><ul><li>v2.16: The LaTeX printing of rooted trees changed to allow representing colored rooted trees. Please update your LaTeX preamble as described in the docstring of <code>RootedTrees.latexify</code>.</li><li>v2.0: Rooted trees are considered up to isomorphisms introduced by shifting each coefficient of their level sequence by the same number.</li></ul><p><strong>Referencing</strong></p><p>If you use <a href="https://github.com/SciML/RootedTrees.jl">RootedTrees.jl</a> for your research, please cite the paper</p><pre><code class="language-bibtex hljs">@article{ketcheson2022computing,
  title={Computing with {B}-series},
  author={Ketcheson, David I and Ranocha, Hendrik},
  journal={ACM Transactions on Mathematical Software},
  year={2022},
  month={12},
  doi={10.1145/3573384},
  eprint={2111.11680},
  eprinttype={arXiv},
  eprintclass={math.NA}
}</code></pre><p>In addition, you can also refer to RootedTrees.jl directly as</p><pre><code class="language-bibtex hljs">@misc{ranocha2019rootedtrees,
  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees
         to generate order conditions for {R}unge-{K}utta methods in {J}ulia
         for differential equations and scientific machine learning ({SciM}L)},
  author={Ranocha, Hendrik and contributors},
  year={2019},
  month={05},
  howpublished={\url{https://github.com/SciML/RootedTrees.jl}},
  doi={10.5281/zenodo.5534590}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L3-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.AdditiveRungeKuttaMethod" href="#RootedTrees.AdditiveRungeKuttaMethod"><code>RootedTrees.AdditiveRungeKuttaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdditiveRungeKuttaMethod(rks)
AdditiveRungeKuttaMethod(As, bs, cs=map(A -&gt; vec(sum(A, dims=2)), As))</code></pre><p>Represent an additive Runge-Kutta method with collections of Butcher coefficients <code>As</code>, <code>bs</code>, and <code>cs</code>. Alternatively, you can pass a collection of <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a>s to the constructor. If the <code>cs</code> are not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p><p>An additive Runge-Kutta method applied to the ODE problem</p><p class="math-container">\[  u&#39;(t) = \sum_\nu f^\nu(t, u(t))\]</p><p>has the form</p><p class="math-container">\[\begin{aligned}
  y^i &amp;= u^n + \Delta t \sum_\nu \sum_j a^\nu_{i,j} f^\nu(y^i), \\
  u^{n+1} &amp;= u^n + \Delta t \sum_\nu \sum_i b^\nu_{i} f^\nu(y^i).
\end{aligned}\]</p><p>In particular, additive Runge-Kutta methods are a superset of partitioned RK methods, which are applied to partitioned problems of the form</p><p class="math-container">\[  (u^1)&#39;(t) = f^1(t, u^1, u^2),
  \quad
  (u^2)&#39;(t) = f^2(t, u^1, u^2).\]</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926-1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L132-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.BicoloredRootedTree" href="#RootedTrees.BicoloredRootedTree"><code>RootedTrees.BicoloredRootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BicoloredRootedTree{T&lt;:Integer}</code></pre><p>Representation of bicolored rooted trees.</p><p>See also <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a>, <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>, <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.BicoloredRootedTreeIterator" href="#RootedTrees.BicoloredRootedTreeIterator"><code>RootedTrees.BicoloredRootedTreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BicoloredRootedTreeIterator(order::Integer)</code></pre><p>Iterator over all bi-colored rooted trees of given <code>order</code>. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a <code>copy</code> has to be made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L394-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.ColoredRootedTree" href="#RootedTrees.ColoredRootedTree"><code>RootedTrees.ColoredRootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColoredRootedTree(level_sequence, color_sequence, is_canonical::Bool=false)</code></pre><p>Represents a colored rooted tree using its level sequence. The single-colored version is <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>.</p><p>See also <a href="#RootedTrees.BicoloredRootedTree"><code>BicoloredRootedTree</code></a>, <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a low-overhead and unsafe constructor. Please consider calling <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a> instead.</p></div></div><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L2-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.PartitionForestIterator" href="#RootedTrees.PartitionForestIterator"><code>RootedTrees.PartitionForestIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionForestIterator(t::AbstractRootedTree, edge_set)</code></pre><p>Lazy iterator representation of the <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> of the rooted tree <code>t</code>. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a>, <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>, and <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L726-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.PartitionIterator" href="#RootedTrees.PartitionIterator"><code>RootedTrees.PartitionIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionIterator(t::AbstractRootedTree)</code></pre><p>Iterator over all partition forests and skeletons of the rooted tree <code>t</code>. This is basically a pure iterator version of <a href="#RootedTrees.all_partitions-Tuple{RootedTree}"><code>all_partitions</code></a>. In particular, the partition forest may only be realized as an iterator. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a>, <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>, and <a href="#RootedTrees.PartitionForestIterator"><code>PartitionForestIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L924-L944">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTree" href="#RootedTrees.RootedTree"><code>RootedTrees.RootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootedTree(level_sequence, is_canonical::Bool=false)</code></pre><p>Represents a rooted tree using its level sequence.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a low-overhead and unsafe constructor. Please consider calling <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a> instead.</p></div></div><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L35-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTreeIterator" href="#RootedTrees.RootedTreeIterator"><code>RootedTrees.RootedTreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootedTreeIterator(order::Integer)</code></pre><p>Iterator over all rooted trees of given <code>order</code>. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a <code>copy</code> has to be made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L540-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RosenbrockMethod" href="#RootedTrees.RosenbrockMethod"><code>RootedTrees.RosenbrockMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RosenbrockMethod(γ, A, b, c=vec(sum(A, dims=2)))</code></pre><p>Represent a Rosenbrock (or Rosenbrock-Wanner, ROW) method with coefficients <code>γ</code>, <code>A</code>, <code>b</code>, and <code>c</code>. If <code>c</code> is not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p><p><strong>Reference</strong></p><ul><li>Ernst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L291-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RungeKuttaMethod" href="#RootedTrees.RungeKuttaMethod"><code>RootedTrees.RungeKuttaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKuttaMethod(A, b, c=vec(sum(A, dims=2)))</code></pre><p>Represent a Runge-Kutta method with Butcher coefficients <code>A</code>, <code>b</code>, and <code>c</code>. If <code>c</code> is not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.SplittingIterator" href="#RootedTrees.SplittingIterator"><code>RootedTrees.SplittingIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplittingIterator(t::RootedTree)</code></pre><p>Iterator over all splitting forests and subtrees of the rooted tree <code>t</code>. This is basically an iterator version of <a href="#RootedTrees.all_splittings-Tuple{RootedTree}"><code>all_splittings</code></a>.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>.</p><p><strong>References</strong></p><p>Section 2.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1126-L1141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.SubtreeIterator" href="#RootedTrees.SubtreeIterator"><code>RootedTrees.SubtreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubtreeIterator(t::AbstractRootedTree)</code></pre><p>Lazy iterator representation of the <a href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>subtrees</code></a> of the rooted tree <code>t</code>. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L607-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}" href="#Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1::ColoredRootedTree, t2::ColoredRootedTree)</code></pre><p>Compares two rooted trees based on their level (first) and color (second) sequences while considering equivalence classes given by different root indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{RootedTree, RootedTree}" href="#Base.:==-Tuple{RootedTree, RootedTree}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1::RootedTree, t2::RootedTree)</code></pre><p>Compares two rooted trees based on their level sequences while considering equivalence classes given by different root indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t1 = rootedtree([1, 2, 3]);

julia&gt; t2 = rootedtree([2, 3, 4]);

julia&gt; t3 = rootedtree([1, 2, 2]);

julia&gt; t1 == t2
true

julia&gt; t1 == t3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L275-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{RootedTree, RootedTree}" href="#Base.:∘-Tuple{RootedTree, RootedTree}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t1 ∘ t2</code></pre><p>The non-associative Butcher product of rooted trees. It is formed by adding an edge from the root of <code>t1</code> to the root of <code>t2</code>.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2016.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1331-L1341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}" href="#Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::ColoredRootedTree, t2::ColoredRootedTree)</code></pre><p>Compares two colored rooted trees using a lexicographical comparison of their level (first) and color (second) sequences while considering equivalence classes given by different root indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{RootedTree, RootedTree}" href="#Base.isless-Tuple{RootedTree, RootedTree}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::RootedTree, t2::RootedTree)</code></pre><p>Compares two rooted trees using a lexicographical comparison of their level sequences while considering equivalence classes given by different root indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L246-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.all_partitions-Tuple{RootedTree}" href="#RootedTrees.all_partitions-Tuple{RootedTree}"><code>RootedTrees.all_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_partitions(t::RootedTree)</code></pre><p>Create all partition forests and skeletons of a rooted tree <code>t</code>. This returns vectors of the return values of <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a> when looping over all possible edge sets.</p><p>See also <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L881-L897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.all_splittings-Tuple{RootedTree}" href="#RootedTrees.all_splittings-Tuple{RootedTree}"><code>RootedTrees.all_splittings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_splittings(t::RootedTree)</code></pre><p>Create all splitting forests and subtrees associated to ordered subtrees of a rooted tree <code>t</code>.</p><p>Seee also <a href="#RootedTrees.SplittingIterator"><code>SplittingIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1066-L1081">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.butcher_representation" href="#RootedTrees.butcher_representation"><code>RootedTrees.butcher_representation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">butcher_representation(t::RootedTree)</code></pre><p>Returns the representation of <code>t::RootedTree</code> introduced by Butcher as a string. Thus, the rooted tree consisting whose only vertex is the root itself is represented as <code>τ</code>. The representation of other trees is defined recursively; if <code>t₁, t₂, ... tₙ</code> are the <a href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>subtrees</code></a> of the rooted tree <code>t</code>, it is represented as <code>t = [t₁ t₂ ... tₙ]</code>. If multiple subtrees are the same, their number of occurences is written as a power.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rootedtree([1, 2, 3, 2]) |&gt; butcher_representation
&quot;[[τ]τ]&quot;

julia&gt; rootedtree([1, 2, 3, 3, 2]) |&gt; butcher_representation
&quot;[[τ²]τ]&quot;</code></pre><p><strong>References</strong></p><p>Section 300 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1348-L1374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.canonical_representation!" href="#RootedTrees.canonical_representation!"><code>RootedTrees.canonical_representation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">canonical_representation!(t::AbstractRootedTree)</code></pre><p>Change the representation of the rooted tree <code>t</code> to the canonical one, i.e., the one with lexicographically biggest level sequence.</p><p>See also <a href="#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}"><code>canonical_representation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L389-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.canonical_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonical_representation(t::AbstractRootedTree)</code></pre><p>Returns a new tree using the canonical representation of the rooted tree <code>t</code>, i.e., the one with lexicographically biggest level sequence.</p><p>See also <a href="#RootedTrees.canonical_representation!"><code>canonical_representation!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L355-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.check_canonical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_canonical(t::AbstractRootedTree)</code></pre><p>Check whether <code>t</code> is in canonical representation.</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L510-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.count_trees-Tuple{Any}" href="#RootedTrees.count_trees-Tuple{Any}"><code>RootedTrees.count_trees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_trees(order)</code></pre><p>Counts all rooted trees of <code>order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L591-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">γ(t::AbstractRootedTree)
density(t::AbstractRootedTree)</code></pre><p>The density <code>γ(t)</code> of a rooted tree, i.e., the product over all vertices of <code>t</code> of the order of the subtree rooted at that vertex.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1278-L1289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for the colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L232-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{RootedTree, RosenbrockMethod}" href="#RootedTrees.derivative_weight-Tuple{RootedTree, RosenbrockMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::RootedTree, ros::RosenbrockMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.RosenbrockMethod"><code>RosenbrockMethod</code></a> <code>ros</code> for the rooted tree <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L362-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::RootedTree, rk::RungeKuttaMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for the rooted tree <code>t</code>.</p><p>Reference: Section 312 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for a colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L205-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{RootedTree, RosenbrockMethod}" href="#RootedTrees.elementary_weight-Tuple{RootedTree, RosenbrockMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::RootedTree, ros::RosenbrockMethod)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.RosenbrockMethod"><code>RosenbrockMethod</code></a> <code>ros</code> for a rooted tree <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L352-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::RootedTree, rk::RungeKuttaMethod)
elementary_weight(t::RootedTree, A::AbstractMatrix, b::AbstractVector, c::AbstractVector)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for a rooted tree <code>t</code>`.</p><p>Reference: Section 312 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.latexify-Tuple{RootedTree}" href="#RootedTrees.latexify-Tuple{RootedTree}"><code>RootedTrees.latexify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latexify(t::Union{RootedTree, BicoloredRootedTree})</code></pre><p>Return a LaTeX representation of the rooted tree <code>t</code>. This makes use of the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a> and assumes that you use the following LaTeX code in the preamble.</p><pre><code class="nohighlight hljs">% Classical and colored Butcher trees based on
% https://tex.stackexchange.com/a/673436
\usepackage{forest}
\forestset{
    whitenode/.style={draw,             circle, minimum size=0.5ex, inner sep=0pt},
    blacknode/.style={draw, fill=black, circle, minimum size=0.5ex, inner sep=0pt},
    colornode/.style={draw, fill=#1,    circle, minimum size=0.5ex, inner sep=0pt},
    colornode/.default={red}
}
\newcommand{\blankforrootedtree}{\rule{0pt}{0pt}}
\NewDocumentCommand\rootedtree{o}{\begin{forest}
    for tree={grow&#39;=90, thick, edge=thick, l sep=0.5ex, l=0pt, s sep=0.5ex},
    delay={
      where content={}{
        for children={no edge, before drawing tree={for tree={y-=5pt}}}
      }
      {
        where content={o}{content={\blankforrootedtree}, whitenode}{
          where content={.}{content={\blankforrootedtree}, blacknode}{}
        }
      }
    }
    [#1]
\end{forest}}
</code></pre><p>To change the style of <code>latexify</code> to a human-readable Butcher-representation, you can use <a href="#RootedTrees.set_latexify_style-Tuple{String}"><code>RootedTrees.set_latexify_style</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rootedtree([1, 2, 2]) |&gt; RootedTrees.latexify |&gt; println
\rootedtree[.[.][.]]

julia&gt; rootedtree([1, 2, 3, 3, 2]) |&gt; RootedTrees.latexify |&gt; println
\rootedtree[.[.[.][.]][.]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/latexify.jl#L2-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.normalize_root!" href="#RootedTrees.normalize_root!"><code>RootedTrees.normalize_root!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_root!(t::AbstractRootedTree, root=one(eltype(t.level_sequence)))</code></pre><p>Normalize the level sequence of the rooted tree <code>t</code> such that the root is set to <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L529-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(t::AbstractRootedTree)</code></pre><p>The <code>order</code> of a rooted tree <code>t</code>, i.e., the length of its level sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1217-L1221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.partition_forest-Tuple{RootedTree, Any}" href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>RootedTrees.partition_forest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_forest(t::RootedTree, edge_set)</code></pre><p>Form the partition forest of the rooted tree <code>t</code> where edges marked with <code>false</code> in the <code>edge_set</code> are removed. The ith value in the Boolean iterable <code>edge_set</code> corresponds to the edge connecting node <code>i+1</code> in the level sequence to its parent.</p><p>See also <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>, <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>, and <a href="#RootedTrees.PartitionForestIterator"><code>PartitionForestIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L673-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}" href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>RootedTrees.partition_skeleton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_skeleton(t::AbstractRootedTree, edge_set)</code></pre><p>Form the partition skeleton of the rooted tree <code>t</code>, i.e., the rooted tree obtained by contracting each tree of the partition forest to a single vertex and re-establishing the edges removed to obtain the partition forest.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 (and Section 6.1 for colored trees) of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L818-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for the colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L264-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{RootedTree, RosenbrockMethod}" href="#RootedTrees.residual_order_condition-Tuple{RootedTree, RosenbrockMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::RootedTree, ros::RosenbrockMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.RosenbrockMethod"><code>RosenbrockMethod</code></a> <code>ros</code> for the rooted tree <code>t</code>.</p><p><strong>Reference</strong></p><ul><li>Ernst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L396-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::RootedTree, rk::RungeKuttaMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for the rooted tree <code>t</code>.</p><p>Reference: Section 315 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/time_integration_methods.jl#L105-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.root_color-Tuple{ColoredRootedTree}" href="#RootedTrees.root_color-Tuple{ColoredRootedTree}"><code>RootedTrees.root_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root_color(t::ColoredRootedTree)</code></pre><p>Return the color of the root of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}" href="#RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}"><code>RootedTrees.rootedtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree!(level_sequence, color_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> object from a <code>level_sequence</code> and a <code>color_sequence</code> which may be modified in this process. See also <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree!-Tuple{AbstractVector}" href="#RootedTrees.rootedtree!-Tuple{AbstractVector}"><code>RootedTrees.rootedtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree!(level_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a> object from a <code>level_sequence</code> which may be modified in this process. See also <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This may modify the <code>level_sequence</code> and further modifications of the <code>level_sequence</code> may invalidate the rooted tree returned by this function. Please consider calling <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a> instead.</p></div></div><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L102-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}" href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>RootedTrees.rootedtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree(level_sequence, color_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> object from a <code>level_sequence</code> and a <code>color_sequence</code>, i.e., a vector of integers representing the levels of each node of the tree and a vector of associated colors (e.g., <code>Bool</code>s or <code>Integers</code>).</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L52-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree-Tuple{AbstractVector}" href="#RootedTrees.rootedtree-Tuple{AbstractVector}"><code>RootedTrees.rootedtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree(level_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a> object from a <code>level_sequence</code>, i.e., a vector of integers representing the levels of each node of the tree.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L62-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.set_latexify_style-Tuple{String}" href="#RootedTrees.set_latexify_style-Tuple{String}"><code>RootedTrees.set_latexify_style</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RootedTrees.set_latexify_style(style::String)</code></pre><p>Set the style of rooted trees when using <a href="#RootedTrees.latexify-Tuple{RootedTree}"><code>latexify</code></a>. Possible options are</p><ul><li>&quot;butcher&quot;: print the <a href="#RootedTrees.butcher_representation"><code>butcher_representation</code></a> of rooted trees</li><li>&quot;forest&quot;: use the LaTeX macro <code>\rootedtree</code> described in the docstring of <a href="#RootedTrees.latexify-Tuple{RootedTree}"><code>latexify</code></a></li></ul><p>This system is based on <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/latexify.jl#L94-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.set_printing_style-Tuple{String}" href="#RootedTrees.set_printing_style-Tuple{String}"><code>RootedTrees.set_printing_style</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RootedTrees.set_printing_style(style::String)</code></pre><p>Set the printing style of rooted trees. Possible options are</p><ul><li>&quot;butcher&quot;: print the <a href="#RootedTrees.butcher_representation"><code>butcher_representation</code></a> of rooted trees</li><li>&quot;sequence&quot;: print the level sequence representation</li></ul><p>This system is based on <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L226-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.subtrees-Tuple{ColoredRootedTree}" href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>RootedTrees.subtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtrees(t::ColoredRootedTree)</code></pre><p>Returns a vector of all subtrees of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/colored_trees.jl#L485-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.subtrees-Tuple{RootedTree}" href="#RootedTrees.subtrees-Tuple{RootedTree}"><code>RootedTrees.subtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtrees(t::RootedTree)</code></pre><p>Returns a vector of all subtrees of <code>t</code>.</p><p>See also <a href="#RootedTrees.SubtreeIterator"><code>SubtreeIterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L646-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.symmetry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ(t::AbstractRootedTree)
symmetry(t::AbstractRootedTree)</code></pre><p>The symmetry <code>σ</code> of a rooted tree <code>t</code>, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of <code>t</code>.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1224-L1235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}" href="#RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}"><code>RootedTrees.unsafe_copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_copyto!(t_dst::AbstractRootedTree, dst_offset,
               t_src::AbstractRootedTree, src_offset, N)</code></pre><p>Copy <code>N</code> nodes from <code>t_src</code> starting at offset <code>src_offset</code> to <code>t_dst</code> starting at offset <code>dst_offset</code>. The types of the rooted trees must match. For example, you cannot copy a <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> to a <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>.</p><p>This is an unsafe operation since the rooted tree <code>t_dst</code> will not necessarily be in canonical representation afterwards, even if the corresponding flag of <code>t_dst</code> is set. Use with caution!</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L168-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}" href="#RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}"><code>RootedTrees.unsafe_deleteat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_deleteat!(t::AbstractRootedTree, i)</code></pre><p>Delete the node <code>i</code> from the rooted tree <code>t</code>. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of <code>t</code> is set. Use with caution!</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L136-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}" href="#RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}"><code>RootedTrees.unsafe_resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_resize!(t::AbstractRootedTree, n::Integer)</code></pre><p>Resize the rooted tree <code>t</code> to <code>n</code> nodes. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of <code>t</code> is set. Use with caution!</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L152-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.α</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α(t::AbstractRootedTree)</code></pre><p>The number of monotonic labelings of <code>t</code> not equivalent under the symmetry group.</p><p>Reference: Section 302 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1302-L1311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.β</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">β(t::AbstractRootedTree)</code></pre><p>The total number of labelings of <code>t</code> not equivalent under the symmetry group.</p><p>Reference: Section 302 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/55eacf1693ada3a29e79c60e65fdee73585b9025/src/RootedTrees.jl#L1316-L1325">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/Rosenbrock_order_conditions/">« Rosenbrock methods</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 25 April 2023 05:33">Tuesday 25 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
