<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · RootedTrees.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://SciML.github.io/RootedTrees.jl/stable/api_reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RootedTrees.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/RK_order_conditions/">Runge-Kutta methods</a></li><li><a class="tocitem" href="../tutorials/ARK_order_conditions/">Additive Runge-Kutta methods</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/RootedTrees.jl/blob/master/docs/src/api_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RootedTrees.jl-API"><a class="docs-heading-anchor" href="#RootedTrees.jl-API">RootedTrees.jl API</a><a id="RootedTrees.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#RootedTrees.jl-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTrees" href="#RootedTrees.RootedTrees"><code>RootedTrees.RootedTrees</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>RootedTrees</strong></p><p><a href="https://SciML.github.io/RootedTrees.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Docs-stable"/></a> <a href="https://SciML.github.io/RootedTrees.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Docs-dev"/></a> <a href="https://github.com/SciML/RootedTrees.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/RootedTrees.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://coveralls.io/github/SciML/RootedTrees.jl?branch=main"><img src="https://coveralls.io/repos/github/SciML/RootedTrees.jl/badge.svg?branch=main" alt="Coverage Status"/></a> <a href="https://codecov.io/gh/SciML/RootedTrees.jl"><img src="https://codecov.io/gh/SciML/RootedTrees.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-success.svg" alt="License: MIT"/></a> <a href="https://doi.org/10.5281/zenodo.5534590"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.5534590.svg" alt="DOI"/></a></p><p>A collection of functionality around rooted trees to generate order conditions for Runge-Kutta methods in <a href="https://julialang.org/">Julia</a>. This package also provides basic functionality for <a href="https://github.com/ranocha/BSeries.jl">BSeries.jl</a>.</p><p><strong>API Documentation</strong></p><p>The API of RootedTrees.jl is documented in the following. Additional information on each function is available in their docstrings and in the <a href="https://SciML.github.io/RootedTrees.jl/stable">online documentation</a>.</p><p><strong>Construction</strong></p><p><code>RootedTree</code>s are represented using level sequences, i.e., <code>AbstractVector</code>s containing the distances of the nodes from the root, see</p><ul><li>Beyer, Terry, and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul><p><code>RootedTree</code>s can be constructed from their level sequence using</p><pre><code class="language-julia hljs">julia&gt; t = rootedtree([1, 2, 3, 2])
RootedTree{Int64}: [1, 2, 3, 2]</code></pre><p>In the notation of <a href="https://doi.org/10.1002/9781119121534">Butcher (Numerical Methods for ODEs, 2016)</a>, this tree can be written as <code>[[τ] τ]</code> or <code>(τ ∘ τ) ∘ (τ ∘ τ)</code>, where <code>∘</code> is the non-associative Butcher product of <code>RootedTree</code>s, which is also implemented.</p><p>To get the representation of a <code>RootedTree</code> introduced by Butcher, use <code>butcher_representation</code>:</p><pre><code class="language-julia hljs">julia&gt; t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])
RootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]

julia&gt; butcher_representation(t)
&quot;[[[τ]τ²]τ⁵]&quot;</code></pre><p>There are also some simple plot recipes for <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. Thus, you can visualize a rooted tree <code>t</code> using <code>plot(t)</code> when <code>using Plots</code>.</p><p>Additionally, there is an un-exported function <code>RootedTrees.latexify</code> that can generate LaTeX code for a rooted tree <code>t</code> based on the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a>. The relevant code that needs to be included in the preamble can be obtained from the docstring of <code>RootedTrees.latexify</code> (type <code>?</code> and <code>RootedTrees.latexify</code> in the Julia REPL). The same format is used when you are <code>using Latexify</code> and their function <code>latexify</code>, see <a href="https://github.com/korsbo/Latexify.jl">Latexify.jl</a>.</p><p><strong>Iteration over <code>RootedTree</code>s</strong></p><p>A <code>RootedTreeIterator(order::Integer)</code> can be used to iterate efficiently over all <code>RootedTree</code>s of a given <code>order</code>.</p><p>Be careful that the iterator is stateful for efficiency reasons, so you might need to use <code>copy</code> appropriately, e.g.,</p><pre><code class="language-julia hljs">julia&gt; map(identity, RootedTreeIterator(4))
4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]

julia&gt; map(copy, RootedTreeIterator(4))
4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:
 RootedTree{Int64}: [1, 2, 3, 4]
 RootedTree{Int64}: [1, 2, 3, 3]
 RootedTree{Int64}: [1, 2, 3, 2]
 RootedTree{Int64}: [1, 2, 2, 2]</code></pre><p><strong>Functions on Trees</strong></p><p>The usual functions on <code>RootedTree</code>s are implemented, cf. <a href="https://doi.org/10.1002/9781119121534">Butcher (Numerical Methods for ODEs, 2016)</a>.</p><ul><li><code>order(t::RootedTree)</code>: The order of a <code>RootedTree</code>, i.e., the length of its level sequence.</li><li><code>σ(t::RootedTree)</code> or <code>symmetry(t)</code>: The symmetry <code>σ</code> of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of <code>t</code>.</li><li><code>γ(t::RootedTree)</code> or <code>density(t)</code>: The density <code>γ(t)</code> of a rooted tree, i.e., the product over all vertices of <code>t</code> of the order of the subtree rooted at that vertex.</li><li><code>α(t::RootedTree)</code>: The number of monotonic labelings of <code>t</code> not equivalent under the symmetry group.</li><li><code>β(t::RootedTree)</code>: The total number of labelings of <code>t</code> not equivalent under the symmetry group.</li></ul><p>Additionally, functions on trees connected to Runge-Kutta methods are implemented.</p><ul><li><code>elementary_weight(t, A, b, c)</code>: Compute the elementary weight Φ(<code>t</code>) of <code>t::RootedTree</code> for the Butcher coefficients <code>A, b, c</code> of a Runge-Kutta method.</li><li><code>derivative_weight(t, A, b, c)</code>: Compute the derivative weight (ΦᵢD)(<code>t</code>) of <code>t</code> for the Butcher coefficients <code>A, b, c</code> of a Runge-Kutta method.</li><li><code>residual_order_condition(t, A, b, c)</code>: The residual of the order condition <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with elementary weight <code>Φ(t)</code>, density <code>γ(t)</code>, and symmetry <code>σ(t)</code> of the rooted tree <code>t</code> for the Runge-Kutta method with Butcher coefficients <code>A, b, c</code>.</li></ul><p><strong>Brief Changelog</strong></p><ul><li>v2.0: Rooted trees are considered up to isomorphisms introduced by shifting each coefficient of their level sequence by the same number.</li></ul><p><strong>Referencing</strong></p><p>If you use <a href="https://github.com/SciML/RootedTrees.jl">RootedTrees.jl</a> for your research, please cite the paper</p><pre><code class="language-bibtex hljs">@online{ketcheson2021computing,
  title={Computing with {B}-series},
  author={Ketcheson, David I and Ranocha, Hendrik},
  year={2021},
  month={11},
  eprint={2111.11680},
  eprinttype={arXiv},
  eprintclass={math.NA}
}</code></pre><p>In addition, you can also refer to RootedTrees.jl directly as</p><pre><code class="language-bibtex hljs">@misc{ranocha2019rootedtrees,
  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees
         to generate order conditions for {R}unge-{K}utta methods in {J}ulia
         for differential equations and scientific machine learning ({SciM}L)},
  author={Ranocha, Hendrik and contributors},
  year={2019},
  month={05},
  howpublished={\url{https://github.com/SciML/RootedTrees.jl}},
  doi={10.5281/zenodo.5534590}
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L3-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.AdditiveRungeKuttaMethod" href="#RootedTrees.AdditiveRungeKuttaMethod"><code>RootedTrees.AdditiveRungeKuttaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdditiveRungeKuttaMethod(rks)
AdditiveRungeKuttaMethod(As, bs, cs=map(A -&gt; vec(sum(A, dims=2)), As))</code></pre><p>Represent an additive Runge-Kutta method with collections of Butcher coefficients <code>As</code>, <code>bs</code>, and <code>cs</code>. Alternatively, you can pass a collection of <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a>s to the constructor. If the <code>cs</code> are not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p><p>An additive Runge-Kutta method applied to the ODE problem</p><p class="math-container">\[  u&#39;(t) = \sum_\nu f^\nu(t, u(t))\]</p><p>has the form</p><p class="math-container">\[\begin{aligned}
  y^i &amp;= u^n + \Delta t \sum_\nu \sum_j a^\nu_{i,j} f^\nu(y^i), \\
  u^{n+1} &amp;= u^n + \Delta t \sum_\nu \sum_i b^\nu_{i} f^\nu(y^i).
\end{aligned}\]</p><p>In particular, additive Runge-Kutta methods are a superset of partitioned RK methods, which are applied to partitioned problems of the form</p><p class="math-container">\[  u^1&#39;(t) = f^1(t, u^1, u^2),
  \quad
  u^2&#39;(t) = f^2(t, u^1, u^2).\]</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926-1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L129-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.BicoloredRootedTree" href="#RootedTrees.BicoloredRootedTree"><code>RootedTrees.BicoloredRootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BicoloredRootedTree{T&lt;:Integer}</code></pre><p>Representation of bicolored rooted trees.</p><p>See also <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a>, <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>, <a href="#RootedTrees.rootedtree-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>rootedtree</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.BicoloredRootedTreeIterator" href="#RootedTrees.BicoloredRootedTreeIterator"><code>RootedTrees.BicoloredRootedTreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BicoloredRootedTreeIterator(order::Integer)</code></pre><p>Iterator over all bi-colored rooted trees of given <code>order</code>. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a <code>copy</code> has to be made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.ColoredRootedTree" href="#RootedTrees.ColoredRootedTree"><code>RootedTrees.ColoredRootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColoredRootedTree(level_sequence, color_sequence, is_canonical::Bool=false)</code></pre><p>Represents a colored rooted tree using its level sequence. The single-colored version is <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>.</p><p>See also <a href="#RootedTrees.BicoloredRootedTree"><code>BicoloredRootedTree</code></a>, <a href="#RootedTrees.rootedtree-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.PartitionForestIterator" href="#RootedTrees.PartitionForestIterator"><code>RootedTrees.PartitionForestIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionForestIterator(t::RootedTree, edge_set)</code></pre><p>Lazy iterator representation of the <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> of the rooted tree <code>t</code>. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a>, <a href="#RootedTrees.partition_skeleton-Tuple{RootedTree, Any}"><code>partition_skeleton</code></a>, and <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L584-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.PartitionIterator" href="#RootedTrees.PartitionIterator"><code>RootedTrees.PartitionIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionIterator(t::RootedTree)</code></pre><p>Iterator over all partition forests and skeletons of the rooted tree <code>t</code>. This is basically a pure iterator version of <a href="#RootedTrees.all_partitions-Tuple{RootedTree}"><code>all_partitions</code></a>. In particular, the partition forest may only be realized as an iterator. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a>, <a href="#RootedTrees.partition_skeleton-Tuple{RootedTree, Any}"><code>partition_skeleton</code></a>, and <a href="#RootedTrees.PartitionForestIterator"><code>PartitionForestIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L786-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTree" href="#RootedTrees.RootedTree"><code>RootedTrees.RootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootedTree(level_sequence, is_canonical::Bool=false)</code></pre><p>Represents a rooted tree using its level sequence.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTreeIterator" href="#RootedTrees.RootedTreeIterator"><code>RootedTrees.RootedTreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootedTreeIterator(order::Integer)</code></pre><p>Iterator over all rooted trees of given <code>order</code>. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a <code>copy</code> has to be made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L401-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RungeKuttaMethod" href="#RootedTrees.RungeKuttaMethod"><code>RootedTrees.RungeKuttaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKuttaMethod(A, b, c=vec(sum(A, dims=2)))</code></pre><p>Represent a Runge-Kutta method with Butcher coefficients <code>A</code>, <code>b</code>, and <code>c</code>. If <code>c</code> is not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.SplittingIterator" href="#RootedTrees.SplittingIterator"><code>RootedTrees.SplittingIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplittingIterator(t::RootedTree)</code></pre><p>Iterator over all splitting forests and subtrees of the rooted tree <code>t</code>. This is basically an iterator version of <a href="#RootedTrees.all_splittings-Tuple{RootedTree}"><code>all_splittings</code></a>.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.partition_skeleton-Tuple{RootedTree, Any}"><code>partition_skeleton</code></a>.</p><p><strong>References</strong></p><p>Section 2.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L983-L998">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}" href="#Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1::ColoredRootedTree, t2::ColoredRootedTree)</code></pre><p>Compares two rooted trees based on their level (first) and color (second) sequences while considering equivalence classes given by different root indices. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{RootedTree, RootedTree}" href="#Base.:==-Tuple{RootedTree, RootedTree}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1::RootedTree, t2::RootedTree)</code></pre><p>Compares two rooted trees based on their level sequences while considering equivalence classes given by different root indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t1 = rootedtree([1, 2, 3]);

julia&gt; t2 = rootedtree([2, 3, 4]);

julia&gt; t3 = rootedtree([1, 2, 2]);

julia&gt; t1 == t2
true

julia&gt; t1 == t3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L158-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{RootedTree, RootedTree}" href="#Base.:∘-Tuple{RootedTree, RootedTree}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t1 ∘ t2</code></pre><p>The non-associative Butcher product of rooted trees. It is formed by adding an edge from the root of <code>t1</code> to the root of <code>t2</code>.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2016.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1195-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}" href="#Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::ColoredRootedTree, t2::ColoredRootedTree)</code></pre><p>Compares two colored rooted trees using a lexicographical comparison of their level (first) and color (second) sequences while considering equivalence classes given by different root indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{RootedTree, RootedTree}" href="#Base.isless-Tuple{RootedTree, RootedTree}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::RootedTree, t2::RootedTree)</code></pre><p>Compares two rooted trees using a lexicographical comparison of their level sequences while considering equivalence classes given by different root indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.all_partitions-Tuple{RootedTree}" href="#RootedTrees.all_partitions-Tuple{RootedTree}"><code>RootedTrees.all_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_partitions(t::RootedTree)</code></pre><p>Create all partition forests and skeletons of a rooted tree <code>t</code>. This returns vectors of the return values of <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.partition_skeleton-Tuple{RootedTree, Any}"><code>partition_skeleton</code></a> when looping over all possible edge sets.</p><p>See also <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L741-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.all_splittings-Tuple{RootedTree}" href="#RootedTrees.all_splittings-Tuple{RootedTree}"><code>RootedTrees.all_splittings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_splittings(t::RootedTree)</code></pre><p>Create all splitting forests and subtrees associated to ordered subtrees of a rooted tree <code>t</code>.</p><p>Seee also <a href="#RootedTrees.SplittingIterator"><code>SplittingIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L922-L937">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.butcher_representation" href="#RootedTrees.butcher_representation"><code>RootedTrees.butcher_representation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">butcher_representation(t::RootedTree)</code></pre><p>Returns the representation of <code>t::RootedTree</code> introduced by Butcher as a string. Thus, the rooted tree consisting whose only vertex is the root itself is represented as <code>τ</code>. The representation of other trees is defined recursively; if <code>t₁, t₂, ... tₙ</code> are the <a href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>subtrees</code></a> of the rooted tree <code>t</code>, it is represented as <code>t = [t₁ t₂ ... tₙ]</code>. If multiple subtrees are the same, their number of occurences is written as a power.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rootedtree([1, 2, 3, 2]) |&gt; butcher_representation
&quot;[[τ]τ]&quot;

julia&gt; rootedtree([1, 2, 3, 3, 2]) |&gt; butcher_representation
&quot;[[τ²]τ]&quot;</code></pre><p><strong>References</strong></p><p>Section 300 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1213-L1239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.canonical_representation!" href="#RootedTrees.canonical_representation!"><code>RootedTrees.canonical_representation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">canonical_representation!(t::RootedTree)</code></pre><p>Change the representation of the rooted tree <code>t</code> to the canonical one, i.e., the one with lexicographically biggest level sequence.</p><p>See also <a href="#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}"><code>canonical_representation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L274-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.canonical_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonical_representation(t::AbstractRootedTree)</code></pre><p>Returns a new tree using the canonical representation of the rooted tree <code>t</code>, i.e., the one with lexicographically biggest level sequence.</p><p>See also <a href="#RootedTrees.canonical_representation!"><code>canonical_representation!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L240-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.count_trees-Tuple{Any}" href="#RootedTrees.count_trees-Tuple{Any}"><code>RootedTrees.count_trees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_trees(order)</code></pre><p>Counts all rooted trees of <code>order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L453-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">γ(t::AbstractRootedTree)
density(t::AbstractRootedTree)</code></pre><p>The density <code>γ(t)</code> of a rooted tree, i.e., the product over all vertices of <code>t</code> of the order of the subtree rooted at that vertex.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1138-L1149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for the colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L229-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::RootedTree, rk::RungeKuttaMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for the rooted tree <code>t</code>.</p><p>Reference: Section 312 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for a colored rooted tree <code>t</code>`.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L201-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::RootedTree, rk::RungeKuttaMethod)
elementary_weight(t::RootedTree, A::AbstractMatrix, b::AbstractVector, c::AbstractVector)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for a rooted tree <code>t</code>`.</p><p>Reference: Section 312 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.latexify-Tuple{RootedTree}" href="#RootedTrees.latexify-Tuple{RootedTree}"><code>RootedTrees.latexify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latexify(t::RootedTree)</code></pre><p>Return a LaTeX representation of the rooted tree <code>t</code>. This makes use of the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a> and assumes that you use the following LaTeX code in the preamble.</p><pre><code class="nohighlight hljs">% Butcher trees, cf. https://tex.stackexchange.com/questions/283343/butcher-trees-in-tikz
\usepackage{forest}
\forestset{
  */.style={
    delay+={append={[]},}
  },
  rooted tree/.style={
    for tree={
      grow&#39;=90,
      parent anchor=center,
      child anchor=center,
      s sep=2.5pt,
      if level=0{
        baseline
      }{},
      delay={
        if content={*}{
          content=,
          append={[]}
        }{}
      }
    },
    before typesetting nodes={
      for tree={
        circle,
        fill,
        minimum width=3pt,
        inner sep=0pt,
        child anchor=center,
      },
    },
    before computing xy={
      for tree={
        l=5pt,
      }
    }
  }
}
\DeclareDocumentCommand\rootedtree{o}{\Forest{rooted tree [#1]}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rootedtree([1, 2, 2]) |&gt; RootedTrees.latexify |&gt; println
\rootedtree[[][]]

julia&gt; rootedtree([1, 2, 3, 3, 2]) |&gt; RootedTrees.latexify |&gt; println
\rootedtree[[[][]][]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/latexify.jl#L2-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.normalize_root!" href="#RootedTrees.normalize_root!"><code>RootedTrees.normalize_root!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_root!(t::AbstractRootedTree, root=one(eltype(t.level_sequence)))</code></pre><p>Normalize the level sequence of the rooted tree <code>t</code> such that the root is set to <code>root</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L388-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(t::AbstractRootedTree)</code></pre><p>The <code>order</code> of a rooted tree <code>t</code>, i.e., the length of its level sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1076-L1080">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.partition_forest-Tuple{RootedTree, Any}" href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>RootedTrees.partition_forest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_forest(t::RootedTree, edge_set)</code></pre><p>Form the partition forest of the rooted tree <code>t</code> where edges marked with <code>false</code> in the <code>edge_set</code> are removed. The ith value in the Boolean iterable <code>edge_set</code> corresponds to the edge connecting node <code>i+1</code> in the level sequence to its parent.</p><p>See also <a href="#RootedTrees.partition_skeleton-Tuple{RootedTree, Any}"><code>partition_skeleton</code></a>, <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>, and <a href="#RootedTrees.PartitionForestIterator"><code>PartitionForestIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L530-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.partition_skeleton-Tuple{RootedTree, Any}" href="#RootedTrees.partition_skeleton-Tuple{RootedTree, Any}"><code>RootedTrees.partition_skeleton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_skeleton(t::RootedTree, edge_set)</code></pre><p>Form the partition skeleton of the rooted tree <code>t</code>, i.e., the rooted tree obtained by contracting each tree of the partition forest to a single vertex and re-establishing the edges removed to obtain the partition forest.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L678-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for the colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L262-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::RootedTree, rk::RungeKuttaMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for the rooted tree <code>t</code>.</p><p>Reference: Section 315 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/time_integration_methods.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#RootedTrees.rootedtree!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>RootedTrees.rootedtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree!(level_sequence, color_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> object from a <code>level_sequence</code> and a <code>color_sequence</code> which may be modified in this process. See also <a href="#RootedTrees.rootedtree-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L65-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree!-Tuple{AbstractVector{T} where T}" href="#RootedTrees.rootedtree!-Tuple{AbstractVector{T} where T}"><code>RootedTrees.rootedtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree!(level_sequence)</code></pre><p>Construct a canonical <code>RootedTree</code> object from a <code>level_sequence</code> which may be modified in this process. See also <a href="#RootedTrees.rootedtree-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L72-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#RootedTrees.rootedtree-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>RootedTrees.rootedtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree(level_sequence, color_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> object from a <code>level_sequence</code> and a <code>color_sequence</code>, i.e., a vector of integers representing the levels of each node of the tree and a vector of associated colors (e.g., <code>Bool</code>s or <code>Integers</code>).</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L42-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree-Tuple{AbstractVector{T} where T}" href="#RootedTrees.rootedtree-Tuple{AbstractVector{T} where T}"><code>RootedTrees.rootedtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree(level_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a> object from a <code>level_sequence</code>, i.e., a vector of integers representing the levels of each node of the tree.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L57-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.subtrees-Tuple{ColoredRootedTree}" href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>RootedTrees.subtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtrees(t::ColoredRootedTree)</code></pre><p>Returns a vector of all subtrees of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/colored_trees.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.subtrees-Tuple{RootedTree}" href="#RootedTrees.subtrees-Tuple{RootedTree}"><code>RootedTrees.subtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtrees(t::RootedTree)</code></pre><p>Returns a vector of all subtrees of <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L502-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.symmetry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ(t::AbstractRootedTree)
symmetry(t::AbstractRootedTree)</code></pre><p>The symmetry <code>σ</code> of a rooted tree <code>t</code>, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of <code>t</code>.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1084-L1095">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.α</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α(t::AbstractRootedTree)</code></pre><p>The number of monotonic labelings of <code>t</code> not equivalent under the symmetry group.</p><p>Reference: Section 302 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1163-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.β</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">β(t::AbstractRootedTree)</code></pre><p>The total number of labelings of <code>t</code> not equivalent under the symmetry group.</p><p>Reference: Section 302 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/RootedTrees.jl/blob/bd097c04599c684607b4c660a204fe2352063d63/src/RootedTrees.jl#L1178-L1187">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/ARK_order_conditions/">« Additive Runge-Kutta methods</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.11 on <span class="colophon-date" title="Sunday 16 January 2022 13:58">Sunday 16 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
