var documenterSearchIndex = {"docs":
[{"location":"api_reference/#RootedTrees.jl-API","page":"API reference","title":"RootedTrees.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = RootedTrees","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [RootedTrees]","category":"page"},{"location":"api_reference/#RootedTrees.RootedTrees","page":"API reference","title":"RootedTrees.RootedTrees","text":"RootedTrees\n\n(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Coverage Status) (Image: codecov) (Image: License: MIT) (Image: DOI) (Image: Downloads)\n\nA collection of functionality around rooted trees to generate order conditions for Runge-Kutta methods in Julia. This package also provides basic functionality for BSeries.jl.\n\nAPI Documentation\n\nThe API of RootedTrees.jl is documented in the following. Additional information on each function is available in their docstrings and in the online documentation.\n\nConstruction\n\nRootedTrees are represented using level sequences, i.e., AbstractVectors containing the distances of the nodes from the root, see\n\nBeyer, Terry, and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\nRootedTrees can be constructed from their level sequence using\n\njulia> t = rootedtree([1, 2, 3, 2])\nRootedTree{Int64}: [1, 2, 3, 2]\n\nIn the notation of Butcher (Numerical Methods for ODEs, 2016), this tree can be written as [[τ] τ] or (τ ∘ τ) ∘ (τ ∘ τ), where ∘ is the non-associative Butcher product of RootedTrees, which is also implemented.\n\nTo get the representation of a RootedTree introduced by Butcher, use butcher_representation:\n\njulia> t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])\nRootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]\n\njulia> butcher_representation(t)\n\"[[[τ]τ²]τ⁵]\"\n\nThere are also some simple plot recipes for Plots.jl. Thus, you can visualize a rooted tree t using plot(t) when using Plots.\n\nAdditionally, there is an un-exported function RootedTrees.latexify that can generate LaTeX code for a rooted tree t based on the LaTeX package forest. The relevant code that needs to be included in the preamble can be obtained from the docstring of RootedTrees.latexify (type ? and RootedTrees.latexify in the Julia REPL). The same format is used when you are using Latexify and their function latexify, see Latexify.jl.\n\nIteration over RootedTrees\n\nA RootedTreeIterator(order::Integer) can be used to iterate efficiently over all RootedTrees of a given order.\n\nBe careful that the iterator is stateful for efficiency reasons, so you might need to use copy appropriately, e.g.,\n\njulia> map(identity, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\njulia> map(copy, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 3, 4]\n RootedTree{Int64}: [1, 2, 3, 3]\n RootedTree{Int64}: [1, 2, 3, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\nFunctions on Trees\n\nThe usual functions on RootedTrees are implemented, cf. Butcher (Numerical Methods for ODEs, 2016).\n\norder(t::RootedTree): The order of a RootedTree, i.e., the length of its level sequence.\nσ(t::RootedTree) or symmetry(t): The symmetry σ of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\nγ(t::RootedTree) or density(t): The density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\nα(t::RootedTree): The number of monotonic labelings of t not equivalent under the symmetry group.\nβ(t::RootedTree): The total number of labelings of t not equivalent under the symmetry group.\n\nAdditionally, functions on trees connected to Runge-Kutta methods are implemented.\n\nelementary_weight(t, A, b, c): Compute the elementary weight Φ(t) of t::RootedTree for the Butcher coefficients A, b, c of a Runge-Kutta method.\nderivative_weight(t, A, b, c): Compute the derivative weight (ΦᵢD)(t) of t for the Butcher coefficients A, b, c of a Runge-Kutta method.\nresidual_order_condition(t, A, b, c): The residual of the order condition (Φ(t) - 1/γ(t)) / σ(t) with elementary weight Φ(t), density γ(t), and symmetry σ(t) of the rooted tree t for the Runge-Kutta method with Butcher coefficients A, b, c.\n\nBrief Changelog\n\nv2.0: Rooted trees are considered up to isomorphisms introduced by shifting each coefficient of their level sequence by the same number.\n\nReferencing\n\nIf you use RootedTrees.jl for your research, please cite the paper\n\n@online{ketcheson2021computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  year={2021},\n  month={11},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}\n\nIn addition, you can also refer to RootedTrees.jl directly as\n\n@misc{ranocha2019rootedtrees,\n  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees\n         to generate order conditions for {R}unge-{K}utta methods in {J}ulia\n         for differential equations and scientific machine learning ({SciM}L)},\n  author={Ranocha, Hendrik and contributors},\n  year={2019},\n  month={05},\n  howpublished={\\url{https://github.com/SciML/RootedTrees.jl}},\n  doi={10.5281/zenodo.5534590}\n}\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#RootedTrees.AdditiveRungeKuttaMethod","page":"API reference","title":"RootedTrees.AdditiveRungeKuttaMethod","text":"AdditiveRungeKuttaMethod(rks)\nAdditiveRungeKuttaMethod(As, bs, cs=map(A -> vec(sum(A, dims=2)), As))\n\nRepresent an additive Runge-Kutta method with collections of Butcher coefficients As, bs, and cs. Alternatively, you can pass a collection of RungeKuttaMethods to the constructor. If the cs are not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\nAn additive Runge-Kutta method applied to the ODE problem\n\n  u(t) = sum_nu f^nu(t u(t))\n\nhas the form\n\nbeginaligned\n  y^i = u^n + Delta t sum_nu sum_j a^nu_ij f^nu(y^i) \n  u^n+1 = u^n + Delta t sum_nu sum_i b^nu_i f^nu(y^i)\nendaligned\n\nIn particular, additive Runge-Kutta methods are a superset of partitioned RK methods, which are applied to partitioned problems of the form\n\n  (u^1)(t) = f^1(t u^1 u^2)\n  quad\n  (u^2)(t) = f^2(t u^1 u^2)\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926-1947. DOI: 10.1137/S0036142995292128\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.BicoloredRootedTree","page":"API reference","title":"RootedTrees.BicoloredRootedTree","text":"BicoloredRootedTree{T<:Integer}\n\nRepresentation of bicolored rooted trees.\n\nSee also ColoredRootedTree, RootedTree, rootedtree.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.BicoloredRootedTreeIterator","page":"API reference","title":"RootedTrees.BicoloredRootedTreeIterator","text":"BicoloredRootedTreeIterator(order::Integer)\n\nIterator over all bi-colored rooted trees of given order. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a copy has to be made.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.ColoredRootedTree","page":"API reference","title":"RootedTrees.ColoredRootedTree","text":"ColoredRootedTree(level_sequence, color_sequence, is_canonical::Bool=false)\n\nRepresents a colored rooted tree using its level sequence. The single-colored version is RootedTree.\n\nSee also BicoloredRootedTree, rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.PartitionForestIterator","page":"API reference","title":"RootedTrees.PartitionForestIterator","text":"PartitionForestIterator(t::AbstractRootedTree, edge_set)\n\nLazy iterator representation of the partition_forest of the rooted tree t. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\nSee also partition_forest, partition_skeleton, and PartitionIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.PartitionIterator","page":"API reference","title":"RootedTrees.PartitionIterator","text":"PartitionIterator(t::AbstractRootedTree)\n\nIterator over all partition forests and skeletons of the rooted tree t. This is basically a pure iterator version of all_partitions. In particular, the partition forest may only be realized as an iterator. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\nSee also partition_forest, partition_skeleton, and PartitionForestIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RootedTree","page":"API reference","title":"RootedTrees.RootedTree","text":"RootedTree(level_sequence, is_canonical::Bool=false)\n\nRepresents a rooted tree using its level sequence.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RootedTreeIterator","page":"API reference","title":"RootedTrees.RootedTreeIterator","text":"RootedTreeIterator(order::Integer)\n\nIterator over all rooted trees of given order. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a copy has to be made.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RosenbrockMethod","page":"API reference","title":"RootedTrees.RosenbrockMethod","text":"RosenbrockMethod(γ, A, b, c=vec(sum(A, dims=2)))\n\nRepresent a Rosenbrock (or Rosenbrock-Wanner, ROW) method with coefficients γ, A, b, and c. If c is not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\nReference\n\nErnst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RungeKuttaMethod","page":"API reference","title":"RootedTrees.RungeKuttaMethod","text":"RungeKuttaMethod(A, b, c=vec(sum(A, dims=2)))\n\nRepresent a Runge-Kutta method with Butcher coefficients A, b, and c. If c is not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.SplittingIterator","page":"API reference","title":"RootedTrees.SplittingIterator","text":"SplittingIterator(t::RootedTree)\n\nIterator over all splitting forests and subtrees of the rooted tree t. This is basically an iterator version of all_splittings.\n\nSee also partition_forest and partition_skeleton.\n\nReferences\n\nSection 2.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.SubtreeIterator","page":"API reference","title":"RootedTrees.SubtreeIterator","text":"SubtreeIterator(t::AbstractRootedTree)\n\nLazy iterator representation of the subtrees of the rooted tree t. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}","page":"API reference","title":"Base.:==","text":"==(t1::ColoredRootedTree, t2::ColoredRootedTree)\n\nCompares two rooted trees based on their level (first) and color (second) sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.:==-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.:==","text":"==(t1::RootedTree, t2::RootedTree)\n\nCompares two rooted trees based on their level sequences while considering equivalence classes given by different root indices.\n\nExamples\n\njulia> t1 = rootedtree([1, 2, 3]);\n\njulia> t2 = rootedtree([2, 3, 4]);\n\njulia> t3 = rootedtree([1, 2, 2]);\n\njulia> t1 == t2\ntrue\n\njulia> t1 == t3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.:∘-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.:∘","text":"t1 ∘ t2\n\nThe non-associative Butcher product of rooted trees. It is formed by adding an edge from the root of t1 to the root of t2.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2016.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}","page":"API reference","title":"Base.isless","text":"isless(t1::ColoredRootedTree, t2::ColoredRootedTree)\n\nCompares two colored rooted trees using a lexicographical comparison of their level (first) and color (second) sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.isless-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.isless","text":"isless(t1::RootedTree, t2::RootedTree)\n\nCompares two rooted trees using a lexicographical comparison of their level sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.all_partitions-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.all_partitions","text":"all_partitions(t::RootedTree)\n\nCreate all partition forests and skeletons of a rooted tree t. This returns vectors of the return values of partition_forest and partition_skeleton when looping over all possible edge sets.\n\nSee also PartitionIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.all_splittings-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.all_splittings","text":"all_splittings(t::RootedTree)\n\nCreate all splitting forests and subtrees associated to ordered subtrees of a rooted tree t.\n\nSeee also SplittingIterator.\n\nReferences\n\nSection 2.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.butcher_representation","page":"API reference","title":"RootedTrees.butcher_representation","text":"butcher_representation(t::RootedTree)\n\nReturns the representation of t::RootedTree introduced by Butcher as a string. Thus, the rooted tree consisting whose only vertex is the root itself is represented as τ. The representation of other trees is defined recursively; if t₁, t₂, ... tₙ are the subtrees of the rooted tree t, it is represented as t = [t₁ t₂ ... tₙ]. If multiple subtrees are the same, their number of occurences is written as a power.\n\nExamples\n\njulia> rootedtree([1, 2, 3, 2]) |> butcher_representation\n\"[[τ]τ]\"\n\njulia> rootedtree([1, 2, 3, 3, 2]) |> butcher_representation\n\"[[τ²]τ]\"\n\nReferences\n\nSection 300 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.canonical_representation!","page":"API reference","title":"RootedTrees.canonical_representation!","text":"canonical_representation!(t::AbstractRootedTree)\n\nChange the representation of the rooted tree t to the canonical one, i.e., the one with lexicographically biggest level sequence.\n\nSee also canonical_representation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.canonical_representation","text":"canonical_representation(t::AbstractRootedTree)\n\nReturns a new tree using the canonical representation of the rooted tree t, i.e., the one with lexicographically biggest level sequence.\n\nSee also canonical_representation!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.check_canonical","text":"check_canonical(t::AbstractRootedTree)\n\nCheck whether t is in canonical representation.\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.count_trees-Tuple{Any}","page":"API reference","title":"RootedTrees.count_trees","text":"count_trees(order)\n\nCounts all rooted trees of order.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.density","text":"γ(t::AbstractRootedTree)\ndensity(t::AbstractRootedTree)\n\nThe density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the AdditiveRungeKuttaMethod ark for the colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{RootedTree, RosenbrockMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::RootedTree, ros::RosenbrockMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the RosenbrockMethod ros for the rooted tree t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::RootedTree, rk::RungeKuttaMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for the rooted tree t.\n\nReference: Section 312 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nCompute the elementary weight Φ(t) of the AdditiveRungeKuttaMethod ark for a colored rooted tree t`.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{RootedTree, RosenbrockMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::RootedTree, ros::RosenbrockMethod)\n\nCompute the elementary weight Φ(t) of the RosenbrockMethod ros for a rooted tree t`.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::RootedTree, rk::RungeKuttaMethod)\nelementary_weight(t::RootedTree, A::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nCompute the elementary weight Φ(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for a rooted tree t`.\n\nReference: Section 312 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.latexify-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.latexify","text":"latexify(t::RootedTree)\n\nReturn a LaTeX representation of the rooted tree t. This makes use of the LaTeX package forest and assumes that you use the following LaTeX code in the preamble.\n\n% Butcher trees, cf. https://tex.stackexchange.com/questions/283343/butcher-trees-in-tikz\n\\usepackage{forest}\n\\forestset{\n  */.style={\n    delay+={append={[]},}\n  },\n  rooted tree/.style={\n    for tree={\n      grow'=90,\n      parent anchor=center,\n      child anchor=center,\n      s sep=2.5pt,\n      if level=0{\n        baseline\n      }{},\n      delay={\n        if content={*}{\n          content=,\n          append={[]}\n        }{}\n      }\n    },\n    before typesetting nodes={\n      for tree={\n        circle,\n        fill,\n        minimum width=3pt,\n        inner sep=0pt,\n        child anchor=center,\n      },\n    },\n    before computing xy={\n      for tree={\n        l=5pt,\n      }\n    }\n  }\n}\n\\DeclareDocumentCommand\\rootedtree{o}{\\Forest{rooted tree [#1]}}\n\nExamples\n\njulia> rootedtree([1, 2, 2]) |> RootedTrees.latexify |> println\n\\rootedtree[[][]]\n\njulia> rootedtree([1, 2, 3, 3, 2]) |> RootedTrees.latexify |> println\n\\rootedtree[[[][]][]]\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.normalize_root!","page":"API reference","title":"RootedTrees.normalize_root!","text":"normalize_root!(t::AbstractRootedTree, root=one(eltype(t.level_sequence)))\n\nNormalize the level sequence of the rooted tree t such that the root is set to root.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.order","text":"order(t::AbstractRootedTree)\n\nThe order of a rooted tree t, i.e., the length of its level sequence.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.partition_forest-Tuple{RootedTree, Any}","page":"API reference","title":"RootedTrees.partition_forest","text":"partition_forest(t::RootedTree, edge_set)\n\nForm the partition forest of the rooted tree t where edges marked with false in the edge_set are removed. The ith value in the Boolean iterable edge_set corresponds to the edge connecting node i+1 in the level sequence to its parent.\n\nSee also partition_skeleton, PartitionIterator, and PartitionForestIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}","page":"API reference","title":"RootedTrees.partition_skeleton","text":"partition_skeleton(t::AbstractRootedTree, edge_set)\n\nForm the partition skeleton of the rooted tree t, i.e., the rooted tree obtained by contracting each tree of the partition forest to a single vertex and re-establishing the edges removed to obtain the partition forest.\n\nSee also partition_forest and PartitionIterator.\n\nReferences\n\nSection 2.3 (and Section 6.1 for colored trees) of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the AdditiveRungeKuttaMethod ark for the colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{RootedTree, RosenbrockMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::RootedTree, ros::RosenbrockMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the RosenbrockMethod ros for the rooted tree t.\n\nReference\n\nErnst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::RootedTree, rk::RungeKuttaMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for the rooted tree t.\n\nReference: Section 315 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.root_color-Tuple{ColoredRootedTree}","page":"API reference","title":"RootedTrees.root_color","text":"root_color(t::ColoredRootedTree)\n\nReturn the color of the root of t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree!","text":"rootedtree!(level_sequence, color_sequence)\n\nConstruct a canonical ColoredRootedTree object from a level_sequence and a color_sequence which may be modified in this process. See also rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree!-Tuple{AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree!","text":"rootedtree!(level_sequence)\n\nConstruct a canonical RootedTree object from a level_sequence which may be modified in this process. See also rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree","text":"rootedtree(level_sequence, color_sequence)\n\nConstruct a canonical ColoredRootedTree object from a level_sequence and a color_sequence, i.e., a vector of integers representing the levels of each node of the tree and a vector of associated colors (e.g., Bools or Integers).\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree-Tuple{AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree","text":"rootedtree(level_sequence)\n\nConstruct a canonical RootedTree object from a level_sequence, i.e., a vector of integers representing the levels of each node of the tree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.set_printing_style-Tuple{String}","page":"API reference","title":"RootedTrees.set_printing_style","text":"RootedTrees.set_printing_style(style::String)\n\nSet the printing style of rooted trees. Possible options are\n\n\"butcher\": print the butcher_representation of rooted trees\n\"sequence\": print the level sequence representation\n\nThis system is based on Preferences.jl.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.subtrees-Tuple{ColoredRootedTree}","page":"API reference","title":"RootedTrees.subtrees","text":"subtrees(t::ColoredRootedTree)\n\nReturns a vector of all subtrees of t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.subtrees-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.subtrees","text":"subtrees(t::RootedTree)\n\nReturns a vector of all subtrees of t.\n\nSee also SubtreeIterator.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.symmetry","text":"σ(t::AbstractRootedTree)\nsymmetry(t::AbstractRootedTree)\n\nThe symmetry σ of a rooted tree t, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}","page":"API reference","title":"RootedTrees.unsafe_copyto!","text":"unsafe_copyto!(t_dst::AbstractRootedTree, dst_offset,\n               t_src::AbstractRootedTree, src_offset, N)\n\nCopy N nodes from t_src starting at offset src_offset to t_dst starting at offset dst_offset. The types of the rooted trees must match. For example, you cannot copy a ColoredRootedTree to a RootedTree.\n\nThis is an unsafe operation since the rooted tree t_dst will not necessarily be in canonical representation afterwards, even if the corresponding flag of t_dst is set. Use with caution!\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}","page":"API reference","title":"RootedTrees.unsafe_deleteat!","text":"unsafe_deleteat!(t::AbstractRootedTree, i)\n\nDelete the node i from the rooted tree t. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of t is set. Use with caution!\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}","page":"API reference","title":"RootedTrees.unsafe_resize!","text":"unsafe_resize!(t::AbstractRootedTree, n::Integer)\n\nResize the rooted tree t to n nodes. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of t is set. Use with caution!\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.α","text":"α(t::AbstractRootedTree)\n\nThe number of monotonic labelings of t not equivalent under the symmetry group.\n\nReference: Section 302 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.β","text":"β(t::AbstractRootedTree)\n\nThe total number of labelings of t not equivalent under the symmetry group.\n\nReference: Section 302 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/SciML/RootedTrees.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2019-present Hendrik RanochaPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"tutorials/ARK_order_conditions/#Additive-Runge-Kutta-methods","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"","category":"section"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"Consider an ordinary differential equation (ODE) of the form","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"u(t) = sum_nu^N f^nu(t u(t))","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"An additive Runge-Kutta (ARK) method with s stages is given by its Butcher coefficients","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"A^nu = (a^nu_ij)_ij in mathbbR^s times s quad\nb^nu = (b^nu_i)_i in mathbbR^s quad\nc^nu = (c^nu_i)_i in mathbbR^s","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"Usually, the consistency condition","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"forall icolon quad c^nu_i = sum_j a^nu_ij","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"is assumed, which reduces all analysis to autonomous problems.","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"The step from u^n to u^n+1 is given by","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"beginaligned\n  y^i = u^n + Delta t sum_nu sum_j a^nu_ij f^nu(y^i) \n  u^n+1 = u^n + Delta t sum_nu sum_i b^nu_i f^nu(y^i)\nendaligned","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"where y^i are the stage values.","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"In RootedTrees.jl, ARK methods are represented as AdditiveRungeKuttaMethods.","category":"page"},{"location":"tutorials/ARK_order_conditions/#Order-conditions","page":"Additive Runge-Kutta methods","title":"Order conditions","text":"","category":"section"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"The order conditions of RK methods can be derived using colored rooted trees. In RootedTrees.jl, this functionality is implemented in residual_order_condition. Thus, an AdditiveRungeKuttaMethod is of order p if the residual_order_condition vanishes for all colored rooted trees with order up to p and N colors. The most important case is N = 2, i.e., BicoloredRootedTrees as special case of ColoredRootedTrees.","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"For example, the classical Störmer-Verlet method can be written as follows, see Table II.2.1 of Hairer, Lubich, Wanner (2002) Geometric numerical integration.","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"using RootedTrees\n\nAs = [\n  [0 0; 1//2 1//2],\n  [1//2 0; 1//2 0]\n]\nbs = [\n  [1//2, 1//2],\n  [1//2, 1//2]\n]\nark = AdditiveRungeKuttaMethod(As, bs)","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"To verify that this method is at least second-order accurate, we can check the residual_order_conditions up to this order.","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"using Test\n\n@testset \"Störmer-Verlet, order 2\" begin\n  for o in 1:2\n    for t in BicoloredRootedTreeIterator(o)\n      @test iszero(residual_order_condition(t, ark))\n    end\n  end\nend\nnothing # hide","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"To verify that this method does not satisfy any of the order conditions for an order of accuracy of three, we can use the following code.","category":"page"},{"location":"tutorials/ARK_order_conditions/","page":"Additive Runge-Kutta methods","title":"Additive Runge-Kutta methods","text":"using Test\n\n@testset \"Störmer-Verlet, not order 3\" begin\n  for t in BicoloredRootedTreeIterator(3)\n    @test !iszero(residual_order_condition(t, ark))\n  end\nend\nnothing # hide","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/SciML/RootedTrees.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingRootedTrees.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.RootedTrees.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"RootedTrees are useful to analyze properties of time integration methods such as Runge-Kutta methods. Some common references introducing them are","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"John Charles Butcher. \"Numerical methods for ordinary differential equations\". John Wiley & Sons, 2016. DOI: 10.1002/9780470753767\nErnst Hairer, Gerhard Wanner, Syvert P. Nørsett. \"Solving Ordinary Differential Equations I\". Springer, 1993. DOI: 10.1007/978-3-540-78862-1\nErnst Hairer, Gerhard Wanner. \"Solving Ordinary Differential Equations II\". Springer, 1996. DOI: 10.1007/978-3-642-05221-7\nErnst Hairer, Gerhard Wanner, Christian Lubich. \"Geometric Numerical Integration\". Springer, 2006. DOI: 10.1007/3-540-30666-8","category":"page"},{"location":"introduction/#Construction","page":"Introduction","title":"Construction","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"RootedTrees are represented using level sequences, i.e., AbstractVectors containing the distances of the nodes from the root, see","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Beyer, Terry, and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"RootedTrees can be constructed from their level sequence using","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> t = rootedtree([1, 2, 3, 2])\nRootedTree{Int64}: [1, 2, 3, 2]","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"In the notation of Butcher (Numerical Methods for ODEs, 2016), this tree can be written as [[τ] τ] or (τ ∘ τ) ∘ (τ ∘ τ), where ∘ is the non-associative Butcher product of RootedTrees, which is also implemented.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"To get the representation of a RootedTree introduced by Butcher, use butcher_representation:","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])\nRootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]\n\njulia> butcher_representation(t)\n\"[[[τ]τ²]τ⁵]\"","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"You can use the function RootedTrees.set_printing_style to change the printing style globally. For example,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"using RootedTrees\nt = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])\nRootedTrees.set_printing_style(\"butcher\")\nt\nRootedTrees.set_printing_style(\"sequence\")\nt","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"There are also some simple plot recipes for Plots.jl. Thus, you can visualize a rooted tree t using plot(t) when using Plots.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Additionally, there is an un-exported function RootedTrees.latexify that can generate LaTeX code for a rooted tree t based on the LaTeX package forest. The relevant code that needs to be included in the preamble can be obtained from the docstring of RootedTrees.latexify (type ? and RootedTrees.latexify in the Julia REPL). The same format is used when you are using Latexify and their function latexify, see Latexify.jl.","category":"page"},{"location":"introduction/#Iteration-over-[RootedTree](@ref)s","page":"Introduction","title":"Iteration over RootedTrees","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"A RootedTreeIterator(order::Integer) can be used to iterate efficiently over all RootedTrees of a given order.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Be careful that the iterator is stateful for efficiency reasons, so you might need to use copy appropriately, e.g.,","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"julia> map(identity, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\njulia> map(copy, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 3, 4]\n RootedTree{Int64}: [1, 2, 3, 3]\n RootedTree{Int64}: [1, 2, 3, 2]\n RootedTree{Int64}: [1, 2, 2, 2]","category":"page"},{"location":"introduction/#Functions-on-Trees","page":"Introduction","title":"Functions on Trees","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"The usual functions on RootedTrees are implemented, cf. Butcher (Numerical Methods for ODEs, 2016).","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"order(t::RootedTree): The order of a RootedTree, i.e., the length of its level sequence.\nσ(t::RootedTree) or symmetry(t): The symmetry σ of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\nγ(t::RootedTree) or density(t): The density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\nα(t::RootedTree): The number of monotonic labelings of t not equivalent under the symmetry group.\nβ(t::RootedTree): The total number of labelings of t not equivalent under the symmetry group.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Additionally, functions on trees connected to Runge-Kutta methods are implemented.","category":"page"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"elementary_weight(t, A, b, c): Compute the elementary weight Φ(t) of t::RootedTree for the Butcher coefficients A, b, c of a Runge-Kutta method.\nderivative_weight(t, A, b, c): Compute the derivative weight (ΦᵢD)(t) of t for the Butcher coefficients A, b, c of a Runge-Kutta method.\nresidual_order_condition(t, A, b, c): The residual of the order condition (Φ(t) - 1/γ(t)) / σ(t) with elementary weight Φ(t), density γ(t), and symmetry σ(t) of the rooted tree t for the Runge-Kutta method with Butcher coefficients A, b, c.","category":"page"},{"location":"tutorials/RK_order_conditions/#Runge-Kutta-methods","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"","category":"section"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"Consider an ordinary differential equation (ODE) of the form","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"u(t) = f(t u(t))","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"A Runge-Kutta (RK) method with s stages is given by its Butcher coefficients","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"A = (a_ij)_ij in mathbbR^s times s quad\nb = (b_i)_i in mathbbR^s quad\nc = (c_i)_i in mathbbR^s","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"which are often written in form of the Butcher tableau","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"beginarrayccc\n  c  A \n  hline\n   b^T \nendarray","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"Usually, the consistency condition","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"forall icolon quad c_i = sum_j a_ij","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"is assumed, which reduces all analysis to autonomous problems.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"The step from u^n to u^n+1 is given by","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"beginaligned\n  y^i = u^n + Delta t sum_j a_ij f(t^n + c_i Delta t y^i) \n  u^n+1 = u^n + Delta t sum_i b_i f(t^n + c_i Delta t y^i)\nendaligned","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"where y^i are the stage values.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"In RootedTrees.jl, RK methods are represented as RungeKuttaMethods.","category":"page"},{"location":"tutorials/RK_order_conditions/#Order-conditions","page":"Runge-Kutta methods","title":"Order conditions","text":"","category":"section"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"The order conditions of RK methods can be derived using rooted trees. In RootedTrees.jl, this functionality is implemented in residual_order_condition. Thus, a RungeKuttaMethod is of order p if the residual_order_condition vanishes for all rooted trees with order up to p.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"For example, the classical fourth-order RK method can be written as follows.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"using RootedTrees\n\nA = [0 0 0 0; 1//2 0 0 0; 0 1//2 0 0; 0 0 1 0]\nb = [1//6, 1//3, 1//3, 1//6]\nrk = RungeKuttaMethod(A, b)","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"To verify that this method is at least fourth-order accurate, we can check the residual_order_conditions up to this order.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"using Test\n\n@testset \"RK4, order 4\" begin\n  for o in 1:4\n    for t in RootedTreeIterator(o)\n      @test iszero(residual_order_condition(t, rk))\n    end\n  end\nend\nnothing # hide","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"To verify that this method does not satisfy any of the order conditions for an order of accuracy of five, we can use the following code.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"using Test\n\n@testset \"RK4, not order 5\" begin\n  for t in RootedTreeIterator(5)\n    @test !iszero(residual_order_condition(t, rk))\n  end\nend\nnothing # hide","category":"page"},{"location":"tutorials/RK_order_conditions/#Symbolic-computation-and-automatic-differentiation","page":"Runge-Kutta methods","title":"Symbolic computation and automatic differentiation","text":"","category":"section"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"The implementation is fully generic using plain Julia code. In particular, this enables automatic differentiation (AD) and symbolic computations.","category":"page"},{"location":"tutorials/RK_order_conditions/#Symbolic-computations","page":"Runge-Kutta methods","title":"Symbolic computations","text":"","category":"section"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"For example, you can determine the order conditions symbolically as follows.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"using SymPy # download required python stuff silently","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"using RootedTrees, SymPy\n\ns = 3 # number of stages\nA = [symbols(\"a_$(i)$(j)\", real=true) for i in 1:s, j in 1:s]\nb = [symbols(\"b_$(i)\", real=true) for i in 1:s]\nrk = RungeKuttaMethod(A, b)\n\nfor o in 1:3\n  println(\"Order \", o)\n  for t in RootedTreeIterator(o)\n    println(\"t = \", t)\n    println(residual_order_condition(t, rk))\n  end\n  println()\nend\n\nnothing # hide","category":"page"},{"location":"tutorials/RK_order_conditions/#Automatic-differentiation","page":"Runge-Kutta methods","title":"Automatic differentiation","text":"","category":"section"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"The order conditions can be differentiated with respect to the Runge-Kutta coefficients. For example, we can use ForwardDiff.jl and Zygote.jl as follows.","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"using RootedTrees, ForwardDiff, Zygote\n\n# collect all rooted trees up to order 4\ntrees = [copy(t) for o in 1:4 for t in RootedTreeIterator(o)]\n\n# classical RK4 method\nA = [0 0 0 0; 1//2 0 0 0; 0 1//2 0 0; 0 0 1 0]\nb = [1//6, 1//3, 1//3, 1//6]\ncoeffs = vcat(vec(A), vec(b)) # one vector of all parameters\n\nfunction all_order_conditions(trees, coeffs)\n  # extract Butcher coefficients from the vector of all coefficients\n  # for an RK method with four stages\n  A = reshape(view(coeffs, 1:16), 4, 4)\n  b = view(coeffs, 17:20)\n  rk = RungeKuttaMethod(A, b)\n  map(t -> residual_order_condition(t, rk), trees)\nend\n\n@assert iszero(all_order_conditions(trees, coeffs)) # fourth-order accurate\n\nForwardDiff.jacobian(coeffs -> all_order_conditions(trees, coeffs), coeffs)","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"Zygote.jacobian(coeffs -> all_order_conditions(trees, coeffs), coeffs)","category":"page"},{"location":"tutorials/RK_order_conditions/","page":"Runge-Kutta methods","title":"Runge-Kutta methods","text":"ForwardDiff.jacobian(coeffs -> all_order_conditions(trees, coeffs), coeffs) == first(Zygote.jacobian(coeffs -> all_order_conditions(trees, coeffs), coeffs))","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/#Rosenbrock-methods","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"","category":"section"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"Consider an ordinary differential equation (ODE) of the form","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"u(t) = f(t u(t))","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"A Rosenbrock (or Rosenbrock-Wanner, ROW) method with s stages is given by its coefficients","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"gamma = (gamma_ij)_ij in mathbbR^s times s quad\nA = (a_ij)_ij in mathbbR^s times s quad\nb = (b_i)_i in mathbbR^s quad\nc = (c_i)_i in mathbbR^s","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"Usually, the consistency condition","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"forall icolon quad c_i = sum_j a_ij","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"is assumed, which reduces all analysis to autonomous problems.","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"The step from u^n to u^n+1 is given by","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"beginaligned\n  k^i = Delta t fbigbl(u^n + sum_j a_ij k^j bibgr) + Delta t J sum_j gamma_ij k_j \n  u^n+1 = u^n + sum_i b_i k^i\nendaligned","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"In RootedTrees.jl, ROW methods are represented as RosenbrockMethods.","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/#Order-conditions","page":"Rosenbrock methods","title":"Order conditions","text":"","category":"section"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"The order conditions of ROW methods can be derived using rooted trees. In RootedTrees.jl, this functionality is again implemented in residual_order_condition. Thus, a RosenbrockMethod is of order p if the residual_order_condition vanishes for all rooted trees with order up to p.","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"For example, the method GRK4A of Kaps and Rentrop (1979) can be written as follows.","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"using RootedTrees\n\nγ = [0.395 0 0 0;\n     -0.767672395484 0.395 0 0;\n     -0.851675323742 0.522967289188 0.395 0;\n     0.288463109545 0.880214273381e-1 -.337389840627 0.395]\nA = [0 0 0 0;\n     0.438 0 0 0;\n     0.796920457938 0.730795420615e-1 0 0;\n     0.796920457938 0.730795420615e-1 0 0]\nb = [0.199293275701, 0.482645235674, 0.680614886256e-1, 0.25]\nros = RosenbrockMethod(γ, A, b)","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"To verify that this method is at least fourth-order accurate, we can check the residual_order_conditions up to this order.","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"using Test\n\n@testset \"GRK4A, order 4\" begin\n  for o in 0:4\n    for t in RootedTreeIterator(o)\n      val = residual_order_condition(t, ros)\n      @test abs(val) < 3000 * eps()\n    end\n  end\nend\nnothing # hide","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"To verify that this method does not satisfy the order conditions for an order of accuracy of five, we can use the following code.","category":"page"},{"location":"tutorials/Rosenbrock_order_conditions/","page":"Rosenbrock methods","title":"Rosenbrock methods","text":"\n@testset \"GRK4A, not order 5\" begin\n  s = 0.0\n  for t in RootedTreeIterator(5)\n    s += abs(residual_order_condition(t, ros))\n  end\n  @test s > 0.06\nend\nnothing # hide","category":"page"},{"location":"#RootedTrees.jl","page":"Home","title":"RootedTrees.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Julia package RootedTrees.jl provides a collection of functionality around rooted trees, including the generation of order conditions for Runge-Kutta methods. This package also provides basic functionality for BSeries.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RootedTrees.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"RootedTrees\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to update RootedTrees.jl, you can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"RootedTrees\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"As usual, if you want to update RootedTrees.jl and all other packages in your current project, you can execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update()","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use RootedTrees.jl for your research, please cite the paper","category":"page"},{"location":"","page":"Home","title":"Home","text":"@online{ketcheson2021computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  year={2021},\n  month={11},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, you can also refer to RootedTrees.jl directly as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ranocha2019rootedtrees,\n  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees\n         to generate order conditions for {R}unge-{K}utta methods in {J}ulia\n         for differential equations and scientific machine learning ({SciM}L)},\n  author={Ranocha, Hendrik and contributors},\n  year={2019},\n  month={05},\n  howpublished={\\url{https://github.com/SciML/RootedTrees.jl}},\n  doi={10.5281/zenodo.5534590}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please also cite the appropriate references for specific functions you use, which can be obtained from their docstrings.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"}]
}
