<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics, printing, and visualization · RootedTrees.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://SciML.github.io/RootedTrees.jl/stable/tutorials/basics/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RootedTrees.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../introduction/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Basics, printing, and visualization</a><ul class="internal"><li><a class="tocitem" href="#Visualization-of-trees"><span>Visualization of trees</span></a></li><li><a class="tocitem" href="#Number-of-trees"><span>Number of trees</span></a></li><li><a class="tocitem" href="#Colored-trees"><span>Colored trees</span></a></li></ul></li><li><a class="tocitem" href="../RK_order_conditions/">Runge-Kutta methods</a></li><li><a class="tocitem" href="../ARK_order_conditions/">Additive Runge-Kutta methods</a></li><li><a class="tocitem" href="../Rosenbrock_order_conditions/">Rosenbrock methods</a></li></ul></li><li><a class="tocitem" href="../../api_reference/">API reference</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Basics, printing, and visualization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basics, printing, and visualization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/RootedTrees.jl/blob/main/docs/src/tutorials/basics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basics,-printing,-and-visualization"><a class="docs-heading-anchor" href="#Basics,-printing,-and-visualization">Basics, printing, and visualization</a><a id="Basics,-printing,-and-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Basics,-printing,-and-visualization" title="Permalink"></a></h1><p>As described in the <a href="../../introduction/#introduction">introduction</a>, <a href="../../api_reference/#RootedTrees.RootedTree"><code>RootedTree</code></a>s are represented using level sequences, i.e., <code>AbstractVector</code>s containing the distances of the nodes from the root. For example,</p><pre><code class="language-julia hljs">using RootedTrees
for t in RootedTreeIterator(4)
    println(t)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RootedTree{Int64}: [1, 2, 3, 4]
RootedTree{Int64}: [1, 2, 3, 3]
RootedTree{Int64}: [1, 2, 3, 2]
RootedTree{Int64}: [1, 2, 2, 2]</code></pre><h2 id="Visualization-of-trees"><a class="docs-heading-anchor" href="#Visualization-of-trees">Visualization of trees</a><a id="Visualization-of-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-of-trees" title="Permalink"></a></h2><p>Depending on your background, you may be more familiar with the classical notation used in the books of Butcher or Hairer &amp; Wanner. You can get these representation via <a href="../../api_reference/#RootedTrees.butcher_representation"><code>butcher_representation</code></a>.</p><pre><code class="language-julia hljs">for t in RootedTreeIterator(4)
    println(butcher_representation(t))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[[[τ]]]
[[τ²]]
[[τ]τ]
[τ³]</code></pre><p>Remember that you can change the printing style globally via <a href="../../api_reference/#RootedTrees.set_printing_style-Tuple{String}"><code>RootedTrees.set_printing_style</code></a>.</p><p>When working with LaTeX, it can be convenient to use the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a> to draw trees. You can find more information about this in the docstring of <a href="../../api_reference/#RootedTrees.latexify-Tuple{RootedTree}"><code>RootedTrees.latexify</code></a>. For example,</p><pre><code class="language-julia hljs">for t in RootedTreeIterator(4)
    println(RootedTrees.latexify(t))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">\rootedtree[.[.[.[.]]]]
\rootedtree[.[.[.][.]]]
\rootedtree[.[.[.]][.]]
\rootedtree[.[.][.][.]]</code></pre><p>This results in the following LaTeX output:</p><p><img src="https://user-images.githubusercontent.com/12693098/196148917-6e3cf000-5bc3-4798-8a82-d6e939bb6a8f.png" alt="latex-trees"/></p><p>If you want to visualize individual trees, you can also use our plot recipes for <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>.</p><pre><code class="language-julia hljs">using Plots
t = rootedtree([1, 2, 3, 3, 2])
plot(t)</code></pre><p><img src="../basics_tree.png" alt/></p><h2 id="Number-of-trees"><a class="docs-heading-anchor" href="#Number-of-trees">Number of trees</a><a id="Number-of-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Number-of-trees" title="Permalink"></a></h2><p>The number of rooted trees grows exponentially. Please consider this when iterating over some set of rooted trees. The implementations in <a href="https://github.com/SciML/RootedTrees.jl">RootedTrees.jl</a> are reasonably efficient, but an exponential growth will always win in the end.</p><p>The function <a href="../../api_reference/#RootedTrees.count_trees-Tuple{Any}"><code>count_trees</code></a> iterates over rooted trees explicitly. Thus, it provides a lower bound on the computational complexity of operations on all trees. For example,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RootedTrees</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time count_trees(10)</code><code class="nohighlight hljs ansi" style="display:block;">  0.000017 seconds (1 allocation: 144 bytes)
719</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time count_trees(20)</code><code class="nohighlight hljs ansi" style="display:block;">  0.397166 seconds (1 allocation: 224 bytes)
12826228</code></pre><p>A nice way to create and print tables of properties of trees is by using the Julia package <a href="https://github.com/ronisbr/PrettyTables.jl">PrettyTables.jl</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RootedTrees, PrettyTables</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; orders = 1:10</code><code class="nohighlight hljs ansi" style="display:block;">1:10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(hcat(orders, count_trees.(orders)), header=[&quot;Order&quot;, &quot;# Trees&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">┌───────┬─────────┐
│<span class="sgr1"> Order │ # Trees │
├───────┼─────────┤
│     1 │       1 │
│     2 │       1 │
│     3 │       2 │
│     4 │       4 │
│     5 │       9 │
│     6 │      20 │
│     7 │      48 │
│     8 │     115 │
│     9 │     286 │
│    10 │     719 │
└───────┴─────────┘</span></code></pre><p>To get the corresponding number of Runge-Kutta (RK) order conditions, we must sum up the number of trees, i.e.,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using RootedTrees, PrettyTables</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; orders = 1:10</code><code class="nohighlight hljs ansi" style="display:block;">1:10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pretty_table(hcat(orders, cumsum(count_trees.(orders))), header=[&quot;Order&quot;, &quot;# RK Order Conditions&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">┌───────┬───────────────────────┐
│<span class="sgr1"> Order │ # RK Order Conditions │
├───────┼───────────────────────┤
│     1 │                     1 │
│     2 │                     2 │
│     3 │                     4 │
│     4 │                     8 │
│     5 │                    17 │
│     6 │                    37 │
│     7 │                    85 │
│     8 │                   200 │
│     9 │                   486 │
│    10 │                  1205 │
└───────┴───────────────────────┘</span></code></pre><p>We can also visualize the exponential growth.</p><pre><code class="language-julia hljs">using Plots
orders = 1:15
scatter(orders, count_trees.(orders), yscale=:log10,
        xguide=&quot;Order&quot;, yguide=&quot;Number of Trees&quot;)</code></pre><p><img src="../basics_count_trees.png" alt/></p><h2 id="Colored-trees"><a class="docs-heading-anchor" href="#Colored-trees">Colored trees</a><a id="Colored-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Colored-trees" title="Permalink"></a></h2><p>A lot of the same functionality is also available for colored trees. Note that the additional choice of different colors increases the number of trees significantly. For example, the number of trees of order 3 increases from</p><pre><code class="language-julia hljs">for t in RootedTreeIterator(3)
    println(t)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RootedTree{Int64}: [1, 2, 3]
RootedTree{Int64}: [1, 2, 2]</code></pre><p>to</p><pre><code class="language-julia hljs">for t in BicoloredRootedTreeIterator(3)
    println(t)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ColoredRootedTree{Int64}: ([1, 2, 3], Bool[0, 0, 0])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[1, 0, 0])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[0, 1, 0])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[1, 1, 0])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[0, 0, 1])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[1, 0, 1])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[0, 1, 1])
ColoredRootedTree{Int64}: ([1, 2, 3], Bool[1, 1, 1])
ColoredRootedTree{Int64}: ([1, 2, 2], Bool[0, 0, 0])
ColoredRootedTree{Int64}: ([1, 2, 2], Bool[1, 0, 0])
ColoredRootedTree{Int64}: ([1, 2, 2], Bool[0, 1, 0])
ColoredRootedTree{Int64}: ([1, 2, 2], Bool[1, 1, 0])
ColoredRootedTree{Int64}: ([1, 2, 2], Bool[0, 1, 1])
ColoredRootedTree{Int64}: ([1, 2, 2], Bool[1, 1, 1])</code></pre><p><a href="../../api_reference/#RootedTrees.latexify-Tuple{RootedTree}"><code>RootedTrees.latexify</code></a> also supports bicolored rooted trees:</p><pre><code class="language-julia hljs">for t in BicoloredRootedTreeIterator(3)
    println(RootedTrees.latexify(t))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">\rootedtree[.[.[.]]]
\rootedtree[o[.[.]]]
\rootedtree[.[o[.]]]
\rootedtree[o[o[.]]]
\rootedtree[.[.[o]]]
\rootedtree[o[.[o]]]
\rootedtree[.[o[o]]]
\rootedtree[o[o[o]]]
\rootedtree[.[.][.]]
\rootedtree[o[.][.]]
\rootedtree[.[o][.]]
\rootedtree[o[o][.]]
\rootedtree[.[o][o]]
\rootedtree[o[o][o]]</code></pre><pre><code class="language-julia hljs">using Plots
t = rootedtree([1, 2, 3, 3, 2, 2], Bool[0, 0, 1, 0, 1, 0])
plot(t)</code></pre><p><img src="../basics_bicolored_tree.png" alt/></p><p>The general implementation supports more than two colors, e.g.,</p><pre><code class="language-julia hljs">using Plots
t = rootedtree([1, 2, 3, 3, 2], [1, 2, 3, 4, 5])
plot(t)</code></pre><p><img src="../basics_colored_tree.png" alt/></p><p>However, the support for multiple colors is limited at the moment, e.g., concerning efficient iterators.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../introduction/">« Introduction</a><a class="docs-footer-nextpage" href="../RK_order_conditions/">Runge-Kutta methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 5 February 2023 11:53">Sunday 5 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
